<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Lógica Matemática &amp; Computacional</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" media="screen" href="css/main.css" />
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
</head>
<body>
    <h1>Introdução</h1>

    <h2>Paradoxo de Russel</h2>
    <p>
        Considere o conjunto de todos os conjuntos que
        não são membros de si mesmos:
    </p>
    <p class="math">
        ` Q := \{ P | P !in Q \} `
        ` :. A in Q => A !in Q `
    </p>

    <h1>Lógica Proposicional</h1>

    <p>
        O objetivo da lógica e da Matemática é modelar situações ou 
        problemas de forma que seja possível raciocinar sobre eles 
        formalmente. A fim de fazer argumentos formais, vamos 
        desenvolver uma lógica simbólica a partir da qual podemos
        expressar sentenças declarativas (ou proposições) e mostrar 
        suas estruturas lógicas. Para isso, vamos definir a linguagem 
        da lógica.
    </p>

    <h2>Alfabeto de Lógica</h2>
    <p>O alfabeto da lógica é constituído por:</p>
    <ul>
        <li>Símbolos de pontuação: <em>(),;.</em></li>
        <li>Símbolos proposicionais: letras romanas e gregas</li>
        <li>Conectivos proposicionais: `^^ vv => <=> not`</li>
    </ul>

    <p>
        As fórmulas da lógica proposicional são constituídas
        indutivamente a partir dos símbolos do alfabeto
        conforme as regras a seguir:
    </p>
    <ul>
        <li>
            Se `H` é uma fórmula, então `not H` é
            fórmula.
        </li>
        <li>
            Se `H, G` são fórmulas, então `H ^^ G`; 
            `H vv G`; `H => G`; e `H <=> G` também são
            fórmulas.
        </li>
        <li>Hipótese `=>` Conclusão</li>
    </ul>

    <p>Os conectivos lógicos satisfazem a seguinte ordem:</p>
    <ol>
        <li>`not`</li>
        <li>`^^ > vv`</li>
        <li>`=> > <=>`</li>
    </ol>

    <p>Convenciona-se que a implicação é associativa à direita.</p>
    <p>Seja `H` uma fórmula da lógica proposicional (LP). Então:</p>
    <ul>
        <li>
            `H` é uma subfórmula de `H` (`H in suf(H)`)
        </li>
        <li>
            Se `H` é uma fórmula do tipo `not G`,
            então `G in suf(H)`
        </li>
        <li>
            Se `H` é uma fórmula do tipo 
            `P ^^ Q`; `P vv Q`; `P => Q`; ou `P <=> Q`,
            então `P, Q in suf(H)`
        </li>
        <li>
            `G in suf(H) => suf(G) sube suf(H)`
        </li>
    </ul>

    <h2>Dedução natural</h2>

    <p>Considere o seguinte argumento:</p>
    <ol>
        <li>
            Se o trem chegar tarde e não existirem taxis na estação,
            então Carlos está atrasado para a reunião.    
        </li>
        <li>
            Carlos não está atrasado para a reunião.
        </li>
        <li>
            O trem chegou tarde.
        </li>
    </ol>
    <p>
        Dela conclui-se que havia taxis na estação. Podemos modelar a 
        situação da seguinte forma:
    </p>
    <p>
        `P := ` "O trem chegar tarde"
    </p>
    <p>
        `Q := ` "Existem taxis na estação"
    </p>
    <p>
        `R := ` "Carlos está atrasado para reunião"
    </p>
    <ol>
        <li>
            `P ^^ not Q => R`
        </li>
        <li>
            `not R`
        </li>
        <li>
            `P`
        </li>
        <li>
            `Q`
        </li>
    </ol>
    <p>
        Vamos ter um conjunto de regras de prova que permitirão
        inferir derivar, concluir fórmulas a partir de outras fórmulas.
        Aplicando estas regras sucessivamente, podemos inferir uma
        conclusão a partir de um conjunto de premissas, que são
        proposições inciais que servem de base oara uma argumentação
        ou para um raciocínio.
    </p>
    
    <h3>Notação</h3>
    <p>
        Suponha que tenhamos um conjunto `\{ phi_i \}_(i=1)^(n)` de proposições
        (as nossas premissas) e uma fórmula `psi` que será a nossa conclusão
        (ou <em>sequente</em>).
    </p> 
    <p class="math">
        `\{ phi_i \}_(i=1)^(n) |-- psi`
    </p>
    <p>
        Suas premissas provam a conclusão. Um sequente é válido se existe uma
        prova para ele.
    </p>

    <h3>Regras</h3>
    <h4>Regras para conjunção</h4>
    <ul>
        <li>
            <p>
                Introdução: sejam `phi, psi` premissas. Então `phi ^^ psi` é
                conclusão. Em notação de árvore:
            </p>
            <p>
                `(phi \ psi)/(phi ^^ psi)`
            </p>
        </li>
        <li>
            <p>
                Eliminação:    
            </p>
            <p>
                `(phi ^^ psi)/(phi)`
            </p>
            <p>
                `(phi ^^ psi)/(psi)`
            </p>
        </li>
    </ul>

    <!-- Exemplo -->
    <p>
        Exemplo: prove que `P ^^ Q, R |-- Q ^^ R`
    </p>
    <div class="math">
        <p>
            `((P ^^ Q)/(Q) \  R )/(Q ^^ R)`
        </p>
        <p>
            $$ 
                \cfrac
                    {\cfrac
                        {P \wedge Q}
                        {Q}
                        \ R
                    }
                    {Q \wedge R} 
                     
            $$
        </p>
    </div>

    <p>
        Exercício: `(P ^^ Q) ^^ R, S ^^ T |-- Q ^^ S`
    </p>

    <h4>Regras para negação</h4>
    <!-- TODO continuar da página 2 -->
</body>
</html>