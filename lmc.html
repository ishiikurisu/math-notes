<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Lógica Matemática &amp; Computacional</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" media="screen" href="css/main.css" />
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
</head>
<body>
    <!-- Página 1 -->
    <h1>Introdução</h1>

    <h2>Paradoxo de Russel</h2>
    <p>
        Considere o conjunto de todos os conjuntos que
        não são membros de si mesmos:
    </p>
    <p class="math">
        ` Q := \{ P | P !in Q \} `
        ` :. A in Q => A !in Q `
    </p>

    <h1>Lógica Proposicional</h1>

    <p>
        O objetivo da lógica e da Matemática é modelar situações ou
        problemas de forma que seja possível raciocinar sobre eles
        formalmente. A fim de fazer argumentos formais, vamos
        desenvolver uma lógica simbólica a partir da qual podemos
        expressar sentenças declarativas (ou proposições) e mostrar
        suas estruturas lógicas. Para isso, vamos definir a linguagem
        da lógica.
    </p>

    <h2>Alfabeto de Lógica</h2>
    <p>O alfabeto da lógica é constituído por:</p>
    <ul>
        <li>Símbolos de pontuação: <em>(),;.</em></li>
        <li>Símbolos proposicionais: letras romanas e gregas</li>
        <li>Conectivos proposicionais: `^^ vv => <=> not`</li>
    </ul>

    <p>
        As fórmulas da lógica proposicional são constituídas
        indutivamente a partir dos símbolos do alfabeto
        conforme as regras a seguir:
    </p>
    <ul>
        <li>
            Se `H` é uma fórmula, então `not H` é
            fórmula.
        </li>
        <li>
            Se `H, G` são fórmulas, então `H ^^ G`;
            `H vv G`; `H => G`; e `H <=> G` também são
            fórmulas.
        </li>
        <li>Hipótese `=>` Conclusão</li>
    </ul>

    <p>Os conectivos lógicos satisfazem a seguinte ordem:</p>
    <ol>
        <li>`not`</li>
        <li>`^^ > vv`</li>
        <li>`=> > <=>`</li>
    </ol>

    <p>Convenciona-se que a implicação é associativa à direita.</p>
    <p>Seja `H` uma fórmula da lógica proposicional (LP). Então:</p>
    <ul>
        <li>
            `H` é uma subfórmula de `H` (`H in suf(H)`)
        </li>
        <li>
            Se `H` é uma fórmula do tipo `not G`,
            então `G in suf(H)`
        </li>
        <li>
            Se `H` é uma fórmula do tipo
            `P ^^ Q`; `P vv Q`; `P => Q`; ou `P <=> Q`,
            então `P, Q in suf(H)`
        </li>
        <li>
            `G in suf(H) => suf(G) sube suf(H)`
        </li>
    </ul>

    <h2>Dedução natural</h2>

    <p>Considere o seguinte argumento:</p>
    <ol>
        <li>
            Se o trem chegar tarde e não existirem taxis na estação,
            então Carlos está atrasado para a reunião.
        </li>
        <li>
            Carlos não está atrasado para a reunião.
        </li>
        <li>
            O trem chegou tarde.
        </li>
    </ol>
    <p>
        Dela conclui-se que havia taxis na estação. Podemos modelar a
        situação da seguinte forma:
    </p>
    <p>
        `P := ` "O trem chegar tarde"
    </p>
    <p>
        `Q := ` "Existem taxis na estação"
    </p>
    <p>
        `R := ` "Carlos está atrasado para reunião"
    </p>
    <ol>
        <li>
            `P ^^ not Q => R`
        </li>
        <li>
            `not R`
        </li>
        <li>
            `P`
        </li>
        <li>
            `Q`
        </li>
    </ol>
    <!-- Página 2 -->
    <p>
        Vamos ter um conjunto de regras de prova que permitirão
        inferir derivar, concluir fórmulas a partir de outras fórmulas.
        Aplicando estas regras sucessivamente, podemos inferir uma
        conclusão a partir de um conjunto de premissas, que são
        proposições inciais que servem de base oara uma argumentação
        ou para um raciocínio.
    </p>

    <h3>Notação</h3>
    <p>
        Suponha que tenhamos um conjunto `\{ phi_i \}_(i=1)^(n)` de proposições
        (as nossas premissas) e uma fórmula `psi` que será a nossa conclusão
        (ou <em>sequente</em>).
    </p>
    <p class="math">
        `\{ phi_i \}_(i=1)^(n) |-- psi`
    </p>
    <p>
        Suas premissas provam a conclusão. Um sequente é válido se existe uma
        prova para ele.
    </p>

    <h3>Regras</h3>
    <h4>Regras para conjunção</h4>
    <ul>
        <li>
            <p>
                Introdução: sejam `phi, psi` premissas. Então `phi ^^ psi` é
                conclusão. Em notação de árvore:
            </p>
            <p  class="math">
                `(phi \ \ psi)/(phi ^^ psi)`
            </p>
        </li>
        <li>
            <p>
                Eliminação:
            </p>
            <p  class="math">
                `(phi ^^ psi)/(phi)`
            </p>
            <p  class="math">
                `(phi ^^ psi)/(psi)`
            </p>
        </li>
    </ul>

    <!-- Exemplo -->
    <p>
        Exemplo: prove que `P ^^ Q, R |-- Q ^^ R`
    </p>
    <p  class="math">
        \(
            \cfrac
                {\cfrac
                    {P \wedge Q}
                    {Q}
                    \ R
                }
                {Q \wedge R}

        \)
    </p>

    <p>
        Exercício: `(P ^^ Q) ^^ R, S ^^ T |-- Q ^^ S`
    </p>

    <h4>Regras para negação</h4>
    <ul>
        <li>
            <p>
                Introdução da dupla negação
            </p>
            <p class="math">
                `(phi)/(not not phi)`
            </p>
        </li>

        <li>
            <p>
                Eliminação da dupla negação
            </p>
            <p class="math">
                `(not not phi)/(phi)`
            </p>
        </li>
    </ul>

    <p>Exercício: `P, not not (Q ^^ R) |-- not not P ^^ R`</p>

    <h4>Regras para implicação</h4>
    <ul>
        <li>
            <p>
                Modus Ponens
            </p>
            <p class="math">
                `(phi => psi \ \ phi)/(psi)`
            </p>
        </li>

        <li>
            <p>
                Modus Tollens
            </p>
            <p class="math">
                `(phi => psi \ \ not psi)/(phi)`
            </p>
        </li>

        <li>
            <p>
                Introdução
            </p>
            <p class="math">
                `({: ([phi]^u), (vdots), (psi) :})/(phi => psi)`
            </p>
        </li>
    </ul>

    <h4>Regras para disjunção</h4>
    <ul>
        <li>
            <p>
                Introdução
            </p>
            <p  class="math">
                `(phi)/(phi vv psi)`
            </p>
            <p  class="math">
                `(psi)/(phi vv psi)`
            </p>
            <p>
                A partir de provas de `phi`, podemos inferir `phi vv psi` verdadeiro para qualquer `psi`.
            </p>
        </li>

        <li>
            <p>
                Eliminação
            </p>
            <p>
                `
                    (
                        phi vv psi \ \
                        {: ([phi]^u), (vdots), (x) :} \ \
                        {: ([psi]^v), (vdots), (x) :}
                    )
                    /
                    (x)
                `
            </p>
        </li>
    </ul>

    <!-- Página 3 -->
    <p>
        Fórmulas lógicas `phi` com sequentes `|-- phi` são chamados <em>Teoremas</em>.
    </p>


    <h3>Propriedades</h3>

    <p>
        A conjunção e a disjunção são distributivas:
    </p>
    <p>
        `(P vv Q) vv R |-- P vv (Q vv R)` e vice-versa
    </p>
    <p>
        `P ^^ (Q vv R) |-- (P ^^ Q) vv (P ^^ R)` e vice-versa
    </p>

    <h4>Propriedades da negação</h4>
    <p>
        Elas involvem a noção de alguma contradição, que são expressões da forma
        `phi ^^ not phi`, onde `hi` é uma fórmula qualquer.
    </p>

    <ul>
        <li>
            <p>
                Eliminação da contradição:
            </p>
            <p>
                `(_|_)/(phi) AA phi`
            </p>
        </li>
        <li>
            <p>
                Eliminação da negação:
            </p>
            <p>
                `(phi \ \ not phi)/(_|_)`
            </p>
        </li>
        <li>
            <p>
                Introdução da negação:
            </p>
            <p>
                `({: ([phi]^u), (vdots), (_|_) :})/(not phi)`
            </p>
        </li>
    </ul>

    <p>
        Exercícios:
    </p>
    <ul>
        <li>
            `P => Q, P => not Q |-- not P`
        </li>
        <li>
            `P => (Q => R), P, not R |-- not Q`
        </li>
    </ul>

    <h4>Propridades da implicação</h4>
    <p>
        A regra "Inclusão da Implicação" pode ser aplicada sem descarregar nenhuma
        hipótese: quando se sabe que `psi` é verdadeiro, `phi => psi AA phi` e
        `not phi => psi AA phi`
    </p>
    <p>
        `([R]^U \ \ Q)/(R => Q)`
    </p>
    <p>
        `:. Q |-- R => R AA R`
    </p>
    <p>
        Observe que a "Inclusão da Implicação" sem descarregamento de premissas pode ser
        substituído por uma derivação com descarregamento.
    </p>
    <p>
        Convenção para descarregamento de hipótese temporária: a
        aplicação de regras com suposições temporárias podem
        descarregar nenhuma ou várias ocorrências de determinada fórmula.
    </p>
    <p>
        Exemplo: `|-- phi => ((phi vv psi) ^^ (phi vv lambda))` é um descarregamento completo.
    </p>

    <p>
        A negação de uma fórmula `phi`, dada por `not phi` pode ser representada
        por `not phi := phi => _|_`.
    </p>

    <h4>Lógicas Intuicionista e Clássica</h4>
    <p>
        A lógica intuicionista (LI) é composta das regras
    </p>
    <ul>
        <li>Inclusão da conjunção</li>
        <li>Eliminação da conjunção</li>
        <li>Inclusão da disjunção</li>
        <li>Eliminação da disjunção</li>
        <li>Inclusão da implicação</li>
        <li>Eliminação da implicação</li>
        <li>Inclusão da negação</li>
        <li>Eliminação da negação</li>
        <li>Eliminação da contradição</li>
    </ul>
    <p>
        Ela é base da matemática construtiva, que não admite a lei do meio
        excluído (`psi vv not psi`). Em LI, esta lei vale se, e somente se,
        (see) há uma prova para `psi` ou `not psi`, enquanto que, na lógica clássica (LC), `psi vv not psi`  é um axioma. Portanto, `LI sube LC`.
    </p>
    <p>
        Para alcançarmos a lógica proposional clássica, adicionaremos uma das
        seguintes regras:
    </p>
    <ul>
        <li>Dupla negação</li>
        <li>Lei do meio excluído</li>
        <li>Prova por contradição</li>
    </ul>
    <p>
        Exercícios:
    </p>
    <ul>
        <li>
            Prove que `not not e, LI` são suficientes para provar `LME,PPC`.
        </li>
        <li>
            Prove `not not e, LME` por `PPC,LI`.
        </li>
    </ul>

    <h4>Propriedades diversas</h4>
    <p>
        Podemos transformar uma prova de
    </p>
    <p class="math">
        `phi_1, phi_2, ..., phi_n |-- psi`
    </p>
    <p>
        em uma prova de
    </p>
    <p class="math">
        `|-- phi_1 => (phi_2 => (... => (phi_n => psi)))`
    </p>
    <br>
    <p>
        Em qualquer estágio de prova, é permitido fazer uma suposição temporária
        desde que ela seja descarregada.
    </p>
    <p>
        Premissas podem ser utilizadas repetidamente (quantas vezes forem
        necessárias).
    </p>
    <p>
        Sejam `phi,psi` fórmulas da LP. Dizemos que elas são equivalentes se
        os sequentes `phi |-- psi` e `psi |-- phi` são válidos. Denota-se por
        \( \phi \dashv \vdash \psi \).
    </p>
    <p>
        Exercícios:
    </p>
    <ul>
        <li>
            \( \neg (p \wedge q) \dashv \vdash \neg p \vee \neg q \)
        </li>
        <li>
            \( p \to q \dashv \vdash \neg q \to \neg p \)
        </li>
        <li>
            \( \neg (p \vee q) \dashv \vdash \neg p \wedge \neg q \)
        </li>
        <li>
            \( p \to q \dashv \vdash \neg p \vee q \)
        </li>
        <li>
            \( (p \wedge q) \to r \dashv \vdash p \to (q \to r) \)
        </li>
    </ul>

    <h1>Semântica da Lógica Proposicional</h1>
    <p>
        A interpretação ou a semântica dis elementos sintáticos da linguagem
        da lógica proposicional é determinada por uma função
        `fr I` denominada "interpretação", que associa a cada fórmula da
        LPum valor verdadeiro (`TT`) ou falso (`_|_`)
    </p>
    <p>
        `fr(I): LP -> \{ TT,_|_ \}`
    </p>
    <p>
        `varphi |-> fr(I)(varphi) = TT,_|_`
    </p>
    <p>
        onde o domínio LP é o conjunto de todas as fórmulas da lógica
        prosicional.
    </p>
    <p>
        As regras da interpretação semântica são dadas pelas
        <em>tabela-verdade</em>.
    </p>
    <table>
        <thead>
            <tr>
                <th>`P`</th>
                <th>`Q`</th>
                <th>`P ^^ Q`</th>
                <th>`P vv Q`</th>
                <th>`P => Q`</th>
                <th>`P <=> Q`</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>`TT`</td>
                <td>`TT`</td>
                <td>`TT`</td>
                <td>`TT`</td>
                <td>`TT`</td>
                <td>`TT`</td>
            </tr>
            <tr>
                <td>`TT`</td>
                <td>`_|_`</td>
                <td>`_|_`</td>
                <td>`TT`</td>
                <td>`_|_`</td>
                <td>`_|_`</td>
            </tr>
            <tr>
                <td>`_|_`</td>
                <td>`TT`</td>
                <td>`_|_`</td>
                <td>`TT`</td>
                <td>`TT`</td>
                <td>`_|_`</td>
            </tr>
            <tr>
                <td>`_|_`</td>
                <td>`_|_`</td>
                <td>`_|_`</td>
                <td>`_|_`</td>
                <td>`TT`</td>
                <td>`TT`</td>
            </tr>
        </tbody>
    </table>

    <h3>Propriedades Semânticas</h3>
    <p>
        Sejam `H,G, \{ H_i \}_(i=1)^(n)` fórmulas da LP. As propriedades
        semânticas são definidas por:
    </p>
    <ul>
        <li>
            `H` é dita <em>tautologia</em> se `fr(I)(H) = TT AA fr(I)`
        </li>
        <li>
            `H` é satisfatível see `EE fr I : fr(I)(H) = TT`
        </li>
        <li>
            `H` é contingente see existem duas interpretações `fr(I)_1`, `fr(I)_2`
            tais que `fr(I)_1(H) = TT` e `fr(I)_2(H) = _|_`.
        </li>
        <li>
            <p>
                `H` implica semanticamente `G` (ou `G` é consequência lógica de
                `H`) see `fr(I)(H) = TT => fr(I)(G) = TT AA fr(I)`.
            </p>
            <p>
                Denota-se `H |== G`.
            </p>
        </li>
        <li>
           `H` equivale semanticamente a `G` see `fr(I)(H) = fr(I)(G) AA fr(I)`
        </li>
        <li>
            Dada uma interpretação `fr(I)`, se `fr(I)(H) = TT`, então diz-se que
            `fr(I)(H)` satisfaz `H`.
        </li>
        <li>
            `H` é contraditório see `fr(I)(H) = _|_ AA fr(I)`
        </li>
    </ul>

    <h2>
        Semântica da Implicação
    </h2>
    <p><em>
        NÃO NECESSARIAMENTE UMA IMPLICAÇÃO POSSUI UMA RELAÇÃO DE CAUSA E EFEITO!
    </em></p>
    <p>
        Na lógica, a fórmula `H => G` representa uma implicação
        material, em que não há necessariamente uma conexão causal
        entre `H` e `G`. O objetivo é dizer que, quando `H` é verdade e
        `fr(I)(H) = TT`, então `G` é verdade, i.e. `fr(I)(G) = TT`. Quando
        falamos da interpretação de `P => Q`, tratamos da fórmula como
        um todo.
    </p>
    <p>
        Se `fr(I)(P) = _|_`, então `fr(I)(P => Q) != TT AA Q`. Informalmente,
        justifica-se que, a partir de uma afirmação falsa, pode-se concluir
        qualquer tipo de declaração.
    </p>
    <h3>
        Exemplos
    </h3>
    <h4>
        Exemplo de Bertrand Russel
    </h4>
    <blockquote>
        Se `2+2=5`, então minha namorada é o Papa.
    </blockquote>
    <ol>
        <li>
            Suponha que `2+2=5`.
        </li>
        <li>
            É fácil que, se este for o caso, então `2=1`.
        </li>
        <li>
            Minha namorada e o Papa são 2 indivíduos. Como `2=1`,
            então minha namorada e o Papa são o mesmo indivíduo.
        </li>
    </ol>
    <h4>
        Exemplo da Álgebra
    </h4>
    <p>
        `P := \{ x in RR | x < 10 \}`
    </p>
    <p>
        `Q := \{ x in RR | x^2 < 100 \}`
    </p>
    <p>
        ` x = 5 :. fr(I)(P) = TT ; fr(I)(Q) = TT :. fr(I)(P => Q) = TT `
    </p>
    <p>
        ` x = -20 :. fr(I)(P) = TT ; fr(I)(Q) = _|_ :. fr(I)(P => Q) = _|_ `
    </p>

    <h3>Causalidade</h3>
    <p>
        Conforme a tabela-verdade da implicação `P => Q`, se `fr(I)(Q) = TT`,
        então `fr(I)(P => Q) = TT AA P`. Logo, `P` e `Q` são independentes.
    </p>
    <ul>
        <li>
            Prove que `P vv not P` é uma tautologia.
        </li>
    </ul>

    <p>
        O conjunto `beta = \{ H_n \}_(n=1)^(oo)` é satisfatível see
        `EE fr(I) | \{ fr(I)(H_n) \}_(n=1)^(oo) -= TT`. Nesse caso, dizemos que
        `fr(I)` satisfaz `beta`. Denota-se `fr(I)(beta) = TT`.
    </p>
    <p>
        Seja `S = \{\}`. Convenciona-se que `fr(I)(\{\}) = TT AA fr(I)`.
    </p>
    <p>
        O conjunto `beta = \{ H_n \}_(n=1)^(oo)` implica semanticamente uma
        fórmula `H` quando existe uma interpretação `fr(I)` tal que, se
        `fr(I)(beta) = TT`, então `fr(I)(H) = TT`. Nesse caso, `H` é
        consequeência semântica de `beta`. Denota-se `B |== H`. No caso em que
        `beta` não implica semanticamente `H`, temos \( \beta \nvDash H \)
    </p>
    <h4>
        Exercícios
    </h4>
    <ul>
        <li>
            <p>
                Considere as seguintes fórmulas:
            </p>
            <p>
                `H_1 := (P_1 ^^ P_2 ^^ P_3 ^^ P_4) => Q`
            </p>
            <p>
                `H_2 := (P_1 ^^ P_2 ^^ P_3 ^^ Q) => Q`
            </p>
            <p>
                `H_3 := (P vv not P) => (Q ^^ not Q)`
            </p>
            <p>
                Qual dessas fórmulas é uma tautologia? Qual é satisfatível?
                Qual é contraditória?
            </p>
        </li>
        <li>
            Mostre que `beta := \{ P, not P, Q \}` é insatisfatível.
        </li>
        <li>
            Mostre que
            `beta := \{ P => Q, Q => R, R => S, S => P, not (S => Q) \}`
            é satisfatível.
        </li>
    </ul>

    <h2>Contradição</h2>
    <p>
        A fórmula `P ^^ not P` está relacionada com o princípio da
        não-contradição da lógica clássica (LC): dada uma proposição e a sua
        negação, pelo menos uma delas é falsa.
    </p>
    <ul>
        <li>
            As fórmulas `H = P ^^ Q` e `G = P` são tais que `H |== G`?
        </li>
    </ul>

    <h2>Relações entre proposições semânticas</h2>
    <h3>Tautologia e contradição</h3>
    <p>
        `H` é uma tautologia see `not H` é contraditória.
    </p>
    <p>
        `not H` não é satisfatível see `not H` é contraditória.
    </p>
    <h3>Tautologia e satisfatibilidade</h3>
    <p>
        Dada uma fórmula `H`, se `H` é tautologia, então `H` é satisfatível.
    </p>
    <h3>Implicação semântica e implicação sintática</h3>
    <p>
        `H |== G <=> fr(I)(H => G) AA fr(I)`.
    </p>
    <h3>Equivalência semântica e "se, e somente se"</h3>
    <p>
        Dadas as fórmulas `H, G`, `H` equivale semanticamente `G` see `H <=> G` é tautologia.
    </p>
    <h3>Equivalência e implicações semânticas</h3>
    <p>
        Dadas as fórmulas `H` e `G`, \( H = \parallel = G \)
        `<=> (H |== G ^^ G |== H)`.
    </p>
    <h3>Transitividade de \(= \parallel = \)</h3>
    <p>
        Dadas as fórmulas `E`, `G` e `H`, se \(E = \parallel = G\) e \(G = \parallel = H\),
        então \( E = \parallel = H \).
    </p>
    <h3>Satisfatibilidade</h3>
    <p>
        Seja `\{ H_i \}_(i=1)^(n)` um conjunto de fórmulas. `\{ H_i \}_(i=1)^(n)`
        é satisfatível see `^^^_(i=1)^(n) H_i` é satisfatível.
    </p>

    <h3>Teorema da dedução, versão semântica</h3>
    <p>
        Considere `beta` um conjunto de fórmulas; e `A, B` duas fórmulas da LP.
    </p>
    <p>
        `beta cup \{ A \} |== B  <=> beta |== A -> B`
    </p>
    <h4>Corolários</h4>
    <ul>
        <li>
            Sejam `H, G` fórmulas da LP. Se `H |== G` e `H` é tautologia, então
            `G` é tautologia.
        </li>
        <li>
            Dadas três fórmulas `A,B,C`: `(A ^^ B) -> C |== A -> (B -> C)`
        </li>
        <li>
            Sejam `H, G` fórmulas.
            Se `\{ H |== G \}`,
            então `\{ \{ |== H \} => \{ |== G \} \}`.
        </li>
        <li>
            Equivalência e tautologia: se `\{ H |== G \}`, então
            `\{ \{ |== H \} <=> \{ |== G \} \}`.
    </ul>

    <h1>Princípio da Indução</h1>
    <h2>Indução Natural</h2>
    <p>
        Permite provar que todo número natural satistaz certa propriedade.
        Suponha que saibamos os seguintes fatos sobre uma propriedade `P`:
    </p>
    <ul>
        <li>
            <strong>Caso base:</strong> `P` vale para o número natural `1`.
            Ou seja, `P(1) = TT`.
        </li>
        <li>
            <strong>Passo indutivo:</strong> Suponha que `P(n)` vale para algum
            natural `n`, é possível provar que `P(n+1)` vale.
        </li>
    </ul>

    <h2>Indução estrutural</h2>
    <p>
        Na Matemática e na Computação, é necessário realizar indução sobre
        estruturas mais elaboradas do que os números naturais. Aqui
        realizaremos indução nos comprimentos das fórmulas da LP.
    </p>
    <p>
        Seja `B(E)` uma afirmação sobre uma fórmula proposicional `E`. Se a
        base e o passo de indução indicados a seguir são verdadeiros, então
        concluímos que `B(E)` é verdadeiro para qualquer fórmula proposicional
        `E`. Assim, o algoritmo é:
    </p>
    <ol>
        <li>
            <strong>Base indutiva:</strong> `B(P)` é válido para qualquer
            fórmula atômica `P`.
        </li>
        <li>
            <strong>Passo indutivo:</strong> Sejam `H, G` duas fórmulas
            proposicionais. Se `B(G)` e `B(H)` são verdadeiras então
            `B(not G), B(H ^^ G), B(H vv G), B(H => G), B(H <=> G)`
            são verdadeiras.
        </li>
    </ol>
    <p>
        <strong>Exercício:</strong>
        Seja `E` uma fórmula proposional. Considere `gamma (E)`
        o número de conectivos lógicos; e `pi (E)`, o número de
        parênteses. Então `gamma(E) = 1/2 pi(E)`.
    </p>
    <p>
        Vamos mostrar utilizando indução estrutural que a estrutura de árvores
        de derivação corresponde à estrutura de fórmulas bem formadas.
    </p>
    <p>
        Indutivamente, uma fórmula `phi` bem-formada é associada a uma árvore
        `T_(phi)` da seguinte forma:
    </p>
    <ul>
        <li>
            No caso em que `phi` é uma fórmula atômica `P` ou uma constante
            `\{ TT, _|_ \}`, a estrutura de árvore associada consiste de um
            único nó rotulado da proposição `P`.
        </li>
        <li>
            Caso `phi := not psi`, para uma fórmula `phi`, a estrutura de
            árvore associada corresponde a um nó rotulado com o conectivo `not`
            e um único nó descendente, que será a raíz da árvore associada a
            `psi`.
        </li>
        <li>
            Caso `phi := psi square varphi` onde
            `square in \{ ^^, vv, =>, <=> \}` para fórmulas bem-formadas `psi`
            e `varphi`: a estrutura associada consiste de um nó rotulado por
            `square` e dois nós descentes rotulados pelas raízes das árvores de
            `psi` e `varphi`.
        </li>
    </ul>

    <h2>Correção da Lógica Proposicional</h2>
    <p>
        As regras de dedução natural permitem uma argumentação rigorosa, pela
        qual chegamos a uma conclusão `varphi` assumindo outras proposições
        `\{ psi_i \}_(i=1)^(n)`. Neste caso, temos que o sequente
        `psi_1, ..., psi_n |-- varphi` é válido. Vamos mostrar que esssas
        regras são corretas no sentido que "sequentes válidos" preserva, a
        verdade calculada pela tabela-verdade semântica.
    </p>
    <p><strong>Exercícios:</strong></p>
    <ul>
        <li>
            `p ^^ q |== p?`
        </li>
        <li>
            `p vv q |== p?`
        </li>
        <li>
            `p ^^ q, not q |== p?`
        </li>
    </ul>

    <h2>Completude da Lógica Proposicional</h2>
    <p>
        Sejam `\{ psi_i \}_(i=1)^(n)` fórmulas proposicionais.
        `psi_1, ..., psi_n |-- varphi` é válida see
        `psi_1, ..., psi_n |== varphi` acontece.
    </p>
    <p>
        Se `\{ psi_i \}_(i=1)^(n) |-- varphi` é válida, existe uma prova de
        `varphi` a partir de `\{ psi_i \}_(i=1)^(n)`. A demonstração deste
        teorema será por indução no comprimento da prova do sequente
        `psi_1, ..., psi_n |-- varphi`.
    </p>
    <p>
        A saber, o cumprimento de uma prova é a quantidade de linhas que esta
        prova possui.
    </p>
    <p>
        Hipótese da indução: suponha qie p resultado seja válido para toda
        prova de tamanho `k`.
    </p>
    <!-- Continuar da página 9 -->
</body>
</html>
